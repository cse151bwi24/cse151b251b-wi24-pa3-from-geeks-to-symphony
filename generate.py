from util import *
from constants import *
from SongRNN import *
import torch
import torch.optim as optim
import torch.nn as nn
import numpy as np

def generate_song(model, device, char_idx_map, max_len=1000, temp=0.8, prime_str='<start>', show_heatmap=False):
    """
    Generates a song using the provided model.

    Parameters:
    - model (nn.Module): The trained model used for generating the song
    - device (torch.device): The device (e.g., "cpu" or "cuda") on which the model is located
    - char_idx_map (dict): A map of characters to their index
    - max_len (int): The maximum length of the generated song
    - temp (float): Temperature parameter for temperature scaling during sampling
    - prime_str (str): Initialize the beginning of the song

    Returns:
    - generated_song (str): The generated song as a string
    """

    #Move model to the specified device and set the model to evaluation mode
    model.to(device)
    model.eval()

    # Initialize the hidden state
    model.init_hidden()
        

    with torch.no_grad(): # we don't need to calculate the gradient in the validation/testing
        # "build up" hidden state using the beginging of a song '<start>'
        generated_song = prime_str
        prime = characters_to_tensor(generated_song, char_idx_map).to(device)
        activations = []
        for i in range(len(prime)):
            _ = model(prime[i])

        '''
        TODOs:
            - Continue generating the rest of the sequence until reaching the maximum length or encountering the end token.
            - Incorporate the temperature parameter to determine the generated/predicted character.
            - Add the generated character to the `generated_song` and then return `generated_song`.
        '''
        sampled_char = None
        for i in range(max_len):
            # Get the last character's index
            
            input_char = prime[-1]

            # Pass the character through the model
            output, _, activation = model(input_char)

            # Apply temperature to restrain ramdomness in the note that the model is generating
            output_dist = nn.functional.softmax(output / temp, dim=0).squeeze().to(device)

            # Sample a character from the distribution
            sampled_char_idx = torch.multinomial(output_dist, 1).to(device)
            prime = torch.cat((prime, sampled_char_idx))

            # Map the sampled index back to a character
            if sampled_char_idx in char_idx_map.values():
                for key, value in char_idx_map.items():
                    if value == sampled_char_idx:
#                         sampled_char = char_idx_map[key]
                        sampled_char = key
                        generated_song += key
            else:
                sampled_char = '<unknown>'
            
            # Retrieving activation values
            activations.append(activation)
            
            # If the sampled character is the end token, break the loop
            if sampled_char == '<end>':
                break

            # Prepare the sampled character for the next iteration
            input_char = characters_to_tensor(sampled_char, char_idx_map)

    
    # Turn the model back to training mode
    model.train()

    if show_heatmap:
#         hi = "char"
        # continue
        # TODO: Call the generate_heatmap function to form the heatmap
        heatmap = torch.cat(activations, dim=0).cpu()
        generate_heatmap(generated_song, heatmap, neuron_idx=1)

#     raise NotImplementedError
    return generated_song

# def generate_heatmap(generated_song, heatmap, neuron_idx=0):
#     """
#     Generates a heatmap using the provided generated song, heatmap chart values, and neuron id.

#     Parameters:
#     - generated_song (nn.Module): The song generated by a trained model.
#     - heatmap (torch.Tensor): Heatmap/activation values from a particular layer of the trained model.
#     - neuron_idx (int): ID of the neuron to plot heatmap for.

#     Returns:
#         None
#     """
#     pad_factor = 20
#     heatmap = heatmap.cpu().detach().numpy()

#     data = np.append(heatmap[:, neuron_idx], 0.0)
#     padded_song, padded_data = pad(generated_song, data, pad_factor=pad_factor)

#     padded_song = np.reshape(padded_song, (len(padded_song) // pad_factor, pad_factor))
#     padded_data = np.reshape(padded_data, (len(padded_data) // pad_factor, pad_factor))

#     print("Heatmap shape:", heatmap.shape)
#     print("padded_song shape:", padded_song.shape)
#     print("padded_data shape:", padded_data.shape)
#     print("Heatmap values:", heatmap)

#     # Print the minimum and maximum values of padded_data
#     print("Min and Max values of Padded Data:", np.min(padded_data), np.max(padded_data))

#     plt.figure(figsize=(heatmap.shape[0] // 4, heatmap.shape[1] // 4))
#     plt.title(f"Heatmap For Song RNN, Neuron ID: {neuron_idx}")

#     # Adjust color scale and range
#     vmin, vmax = np.min(padded_data), np.max(padded_data)
#     plt.pcolor(padded_data, edgecolors='k', linewidths=4, cmap='RdBu_r', vmin=vmin, vmax=vmax)

#     # Uncomment the next line if show_values is defined and needed
#     # show_values(heatplot, song=padded_song)
    
#     plt.colorbar()
#     plt.gca().invert_yaxis()
#     plt.show()

#     plt.savefig(f"./plots/heatmap_{neuron_idx}.png")
#     print(f"==> Heatmap saved for Neuron ID: {neuron_idx}..")
#     return
def generate_heatmap(generated_song, heatmap, neuron_idx=0):
    """
    Generates a heatmap using the provided generated song, heatmap chart values, and neuron id.

    Parameters:
    - generated_song (nn.Module): The song generated by a trained model.
    - heatmap (torch.Tensor): Heatmap/activation values from a particular layer of the trained model.
    - neuron_idx (int): ID of the neuron to plot heatmap for.

    Returns:
        None
    """
    pad_factor = 20
    heatmap = heatmap.cpu().detach().numpy()

    data = np.append(heatmap[:, neuron_idx], 0.0)
    padded_song, padded_data = pad(generated_song, data, pad_factor=pad_factor)

    padded_song = np.reshape(padded_song, (len(padded_song) // pad_factor, pad_factor))
    padded_data = np.reshape(padded_data, (len(padded_data) // pad_factor, pad_factor))

    # Increase the figure size
    plt.figure(figsize=(10,8))

    plt.title(f"Heatmap For Song RNN, Neuron ID: {neuron_idx}")

    # Adjust color scale and range
    vmin, vmax = np.min(padded_data), np.max(padded_data)

    # Use plt.imshow instead of plt.pcolor
    plt.imshow(padded_data, cmap='RdBu_r', vmin=vmin, vmax=vmax, aspect='auto', interpolation='nearest')
    
    print(padded_data.shape)
    
    for i in range(padded_data.shape[0]):
        for j in range(padded_data.shape[1]):
            plt.text(j, i, f'{padded_data[i, j]:.2f}', ha='center', va='center', color='black', fontsize=8)


    # Uncomment the next line if show_values is defined and needed
    # show_values(heatplot, song=padded_song)
    
    plt.colorbar()
    plt.gca().invert_yaxis()
    plt.show()

    plt.savefig(f"./plots/heatmap_{neuron_idx}.png")
    print(f"==> Heatmap saved for Neuron ID: {neuron_idx}..")
    return